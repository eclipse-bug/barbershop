{"ast":null,"code":"import _objectSpread from \"C:/wamp64/www/barbershop/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/wamp64/www/barbershop/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"motionValue\", \"onUpdate\", \"onComplete\", \"element\"];\nimport { secondsToMilliseconds } from 'motion-utils';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { NativeAnimation } from './NativeAnimation.mjs';\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\nimport { replaceStringEasing } from './waapi/utils/unsupported-easing.mjs';\n\n/**\r\n * 10ms is chosen here as it strikes a balance between smooth\r\n * results (more than one keyframe per frame at 60fps) and\r\n * keyframe quantity.\r\n */\nconst sampleDelta = 10; //ms\nclass NativeAnimationExtended extends NativeAnimation {\n  constructor(options) {\n    /**\r\n     * The base NativeAnimation function only supports a subset\r\n     * of Motion easings, and WAAPI also only supports some\r\n     * easing functions via string/cubic-bezier definitions.\r\n     *\r\n     * This function replaces those unsupported easing functions\r\n     * with a JS easing function. This will later get compiled\r\n     * to a linear() easing function.\r\n     */\n    replaceStringEasing(options);\n    /**\r\n     * Ensure we replace the transition type with a generator function\r\n     * before passing to WAAPI.\r\n     *\r\n     * TODO: Does this have a better home? It could be shared with\r\n     * JSAnimation.\r\n     */\n    replaceTransitionType(options);\n    super(options);\n    if (options.startTime) {\n      this.startTime = options.startTime;\n    }\n    this.options = options;\n  }\n  /**\r\n   * WAAPI doesn't natively have any interruption capabilities.\r\n   *\r\n   * Rather than read commited styles back out of the DOM, we can\r\n   * create a renderless JS animation and sample it twice to calculate\r\n   * its current value, \"previous\" value, and therefore allow\r\n   * Motion to calculate velocity for any subsequent animation.\r\n   */\n  updateMotionValue(value) {\n    var _this$finishedTime;\n    const _this$options = this.options,\n      {\n        motionValue,\n        onUpdate,\n        onComplete,\n        element\n      } = _this$options,\n      options = _objectWithoutProperties(_this$options, _excluded);\n    if (!motionValue) return;\n    if (value !== undefined) {\n      motionValue.set(value);\n      return;\n    }\n    const sampleAnimation = new JSAnimation(_objectSpread(_objectSpread({}, options), {}, {\n      autoplay: false\n    }));\n    const sampleTime = secondsToMilliseconds((_this$finishedTime = this.finishedTime) !== null && _this$finishedTime !== void 0 ? _this$finishedTime : this.time);\n    motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n    sampleAnimation.stop();\n  }\n}\nexport { NativeAnimationExtended };","map":{"version":3,"names":["secondsToMilliseconds","JSAnimation","NativeAnimation","replaceTransitionType","replaceStringEasing","sampleDelta","NativeAnimationExtended","constructor","options","startTime","updateMotionValue","value","_this$finishedTime","_this$options","motionValue","onUpdate","onComplete","element","_objectWithoutProperties","_excluded","undefined","set","sampleAnimation","_objectSpread","autoplay","sampleTime","finishedTime","time","setWithVelocity","sample","stop"],"sources":["C:/wamp64/www/barbershop/frontend/node_modules/motion-dom/dist/es/animation/NativeAnimationExtended.mjs"],"sourcesContent":["import { secondsToMilliseconds } from 'motion-utils';\r\nimport { JSAnimation } from './JSAnimation.mjs';\r\nimport { NativeAnimation } from './NativeAnimation.mjs';\r\nimport { replaceTransitionType } from './utils/replace-transition-type.mjs';\r\nimport { replaceStringEasing } from './waapi/utils/unsupported-easing.mjs';\r\n\r\n/**\r\n * 10ms is chosen here as it strikes a balance between smooth\r\n * results (more than one keyframe per frame at 60fps) and\r\n * keyframe quantity.\r\n */\r\nconst sampleDelta = 10; //ms\r\nclass NativeAnimationExtended extends NativeAnimation {\r\n    constructor(options) {\r\n        /**\r\n         * The base NativeAnimation function only supports a subset\r\n         * of Motion easings, and WAAPI also only supports some\r\n         * easing functions via string/cubic-bezier definitions.\r\n         *\r\n         * This function replaces those unsupported easing functions\r\n         * with a JS easing function. This will later get compiled\r\n         * to a linear() easing function.\r\n         */\r\n        replaceStringEasing(options);\r\n        /**\r\n         * Ensure we replace the transition type with a generator function\r\n         * before passing to WAAPI.\r\n         *\r\n         * TODO: Does this have a better home? It could be shared with\r\n         * JSAnimation.\r\n         */\r\n        replaceTransitionType(options);\r\n        super(options);\r\n        if (options.startTime) {\r\n            this.startTime = options.startTime;\r\n        }\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * WAAPI doesn't natively have any interruption capabilities.\r\n     *\r\n     * Rather than read commited styles back out of the DOM, we can\r\n     * create a renderless JS animation and sample it twice to calculate\r\n     * its current value, \"previous\" value, and therefore allow\r\n     * Motion to calculate velocity for any subsequent animation.\r\n     */\r\n    updateMotionValue(value) {\r\n        const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\r\n        if (!motionValue)\r\n            return;\r\n        if (value !== undefined) {\r\n            motionValue.set(value);\r\n            return;\r\n        }\r\n        const sampleAnimation = new JSAnimation({\r\n            ...options,\r\n            autoplay: false,\r\n        });\r\n        const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);\r\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\r\n        sampleAnimation.stop();\r\n    }\r\n}\r\n\r\nexport { NativeAnimationExtended };\r\n"],"mappings":";;;AAAA,SAASA,qBAAqB,QAAQ,cAAc;AACpD,SAASC,WAAW,QAAQ,mBAAmB;AAC/C,SAASC,eAAe,QAAQ,uBAAuB;AACvD,SAASC,qBAAqB,QAAQ,qCAAqC;AAC3E,SAASC,mBAAmB,QAAQ,sCAAsC;;AAE1E;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG,EAAE,CAAC,CAAC;AACxB,MAAMC,uBAAuB,SAASJ,eAAe,CAAC;EAClDK,WAAWA,CAACC,OAAO,EAAE;IACjB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQJ,mBAAmB,CAACI,OAAO,CAAC;IAC5B;AACR;AACA;AACA;AACA;AACA;AACA;IACQL,qBAAqB,CAACK,OAAO,CAAC;IAC9B,KAAK,CAACA,OAAO,CAAC;IACd,IAAIA,OAAO,CAACC,SAAS,EAAE;MACnB,IAAI,CAACA,SAAS,GAAGD,OAAO,CAACC,SAAS;IACtC;IACA,IAAI,CAACD,OAAO,GAAGA,OAAO;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIE,iBAAiBA,CAACC,KAAK,EAAE;IAAA,IAAAC,kBAAA;IACrB,MAAAC,aAAA,GAAmE,IAAI,CAACL,OAAO;MAAzE;QAAEM,WAAW;QAAEC,QAAQ;QAAEC,UAAU;QAAEC;MAAoB,CAAC,GAAAJ,aAAA;MAATL,OAAO,GAAAU,wBAAA,CAAAL,aAAA,EAAAM,SAAA;IAC9D,IAAI,CAACL,WAAW,EACZ;IACJ,IAAIH,KAAK,KAAKS,SAAS,EAAE;MACrBN,WAAW,CAACO,GAAG,CAACV,KAAK,CAAC;MACtB;IACJ;IACA,MAAMW,eAAe,GAAG,IAAIrB,WAAW,CAAAsB,aAAA,CAAAA,aAAA,KAChCf,OAAO;MACVgB,QAAQ,EAAE;IAAK,EAClB,CAAC;IACF,MAAMC,UAAU,GAAGzB,qBAAqB,EAAAY,kBAAA,GAAC,IAAI,CAACc,YAAY,cAAAd,kBAAA,cAAAA,kBAAA,GAAI,IAAI,CAACe,IAAI,CAAC;IACxEb,WAAW,CAACc,eAAe,CAACN,eAAe,CAACO,MAAM,CAACJ,UAAU,GAAGpB,WAAW,CAAC,CAACM,KAAK,EAAEW,eAAe,CAACO,MAAM,CAACJ,UAAU,CAAC,CAACd,KAAK,EAAEN,WAAW,CAAC;IAC1IiB,eAAe,CAACQ,IAAI,CAAC,CAAC;EAC1B;AACJ;AAEA,SAASxB,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}